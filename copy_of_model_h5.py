# -*- coding: utf-8 -*-
"""Copy of model.h5

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FlzbSftvfO582M9XHa0LzcPR7pgvyCxa
"""

from google.colab import drive
drive.mount('/content/drive')

# Import necessary libraries
import os
import tensorflow as tf
from tensorflow.keras import layers, models
from tensorflow.keras.preprocessing.image import ImageDataGenerator

# Set paths and parameters
train_path = '/content/drive/MyDrive/Colab Notebooks/shoplifting.v1i (2).tensorflow/train'
valid_path = '/content/drive/MyDrive/Colab Notebooks/shoplifting.v1i (2).tensorflow/valid'
batch_size = 32
epochs = 10
img_height = 180
img_width = 180

# Data preprocessing using ImageDataGenerator
from keras.preprocessing.image import ImageDataGenerator

train_datagen = ImageDataGenerator(rescale=1./255)
valid_datagen = ImageDataGenerator(rescale=1./255)

train_generator = train_datagen.flow_from_directory(
    train_path,
    target_size=(img_height, img_width),
    batch_size=batch_size,
    class_mode='binary')

valid_generator = valid_datagen.flow_from_directory(
    valid_path,
    target_size=(img_height, img_width),
    batch_size=batch_size,
    class_mode='binary')

train_datagen = ImageDataGenerator(
    rescale=1./255,
    rotation_range=20,
    width_shift_range=0.2,
    height_shift_range=0.2,
    shear_range=0.2,
    zoom_range=0.2,
    horizontal_flip=True,
    fill_mode='nearest'
)

from keras.layers import Conv2D, MaxPooling2D, Flatten, Dense
from tensorflow.keras.models import Sequential

model = Sequential()

model.add(Conv2D(32, (3, 3), activation='relu', input_shape=(img_height, img_width, 3)))
model.add(MaxPooling2D((2, 2)))
model.add(Conv2D(64, (3, 3), activation='relu'))
model.add(MaxPooling2D((2, 2)))
model.add(Conv2D(64, (3, 3), activation='relu'))
model.add(Flatten())
model.add(Dense(64, activation='relu'))
model.add(Dense(1, activation='sigmoid'))
model.summary()

#from keras.layers import Flatten, Dense

# Flatten the data for the fully connected layer
#model.add(Flatten())
#model.add(Dense(64, activation='relu'))
#model.add(Dense(1, activation='sigmoid'))

# Compile the model
from tensorflow.keras.optimizers import Adam

model.compile(optimizer=Adam(lr=0.001),
              loss='binary_crossentropy',
              metrics=['accuracy'])

# Train the model
history = model.fit(
    train_generator,
    epochs=epochs,
    validation_data=valid_generator)

train_steps_per_epoch = len(train_generator)
valid_steps_per_epoch = len(valid_generator)

print("Number of steps per epoch for training:", train_steps_per_epoch)
print("Number of steps per epoch for validation:", valid_steps_per_epoch)

import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import numpy as np
from tensorflow.keras.preprocessing import image
from tensorflow.keras.applications.vgg16 import preprocess_input, decode_predictions

# Define your image dimensions
img_height, img_width = 224, 224  # Update with the actual dimensions

# Define your alert function
def alert_function():
    send_email("Shoplifting Alert", "A potential shoplifting incident has been detected. Please check the surveillance system.")

# Load your model (make sure you have it defined somewhere in your code)
# model = ...

# Function to predict image
def predict_image(img_array):
    # Preprocess the image before making predictions
    img_array = preprocess_input(img_array)

    # Make a prediction using the trained model
    prediction = model.predict(img_array)

    # Postprocess the prediction
    if prediction > 0.5:
        alert_function()  # Call the alert function if shoplifting is detected
        return 'The image is more likely to be a shoplifter.'
    else:
        return 'The image is more likely not to be a shoplifter.'

# Function to preprocess image for prediction
def load_and_preprocess_image(file):
    img = image.load_img(file, target_size=(img_height, img_width))
    img_array = image.img_to_array(img)
    img_array = np.expand_dims(img_array, axis=0)
    return img_array / 255.0

def send_email(subject, body):
    # Sender's email address and password
    sender_email = "anjalimane1721@gmail.com"  # Replace with your email
    sender_password = "fkgz alnd gdjo ajrp"  # Replace with your email password

    # Receiver's email address
    receiver_email = "anjali.mane@cumminscollege.in"  # Replace with recipient's email

    # Set up the MIME
    message = MIMEMultipart()
    message["From"] = sender_email
    message["To"] = receiver_email
    message["Subject"] = subject

    # Attach the body to the email
    message.attach(MIMEText(body, "plain"))

    try:
        # Establish a secure session with the SMTP server
        with smtplib.SMTP_SSL("smtp.gmail.com", 465) as server:
            # Log in to the email account
            server.login(sender_email, sender_password)

            # Send the email
            server.sendmail(sender_email, receiver_email, message.as_string())

        print("Email sent successfully!")
    except Exception as e:
        print(f"Error sending email: {e}")

def alert_function():
    send_email("Shoplifting Alert", "A potential shoplifting incident has been detected. Please check the surveillance system.")

!pip install ipywidgets

from tensorflow.keras.applications.vgg16 import preprocess_input, decode_predictions
from IPython.display import clear_output
from PIL import Image
from ipywidgets import FileUpload, HBox, Output
from io import BytesIO
from PIL import Image

# Define the UI
uploaded_file = FileUpload(accept='.jpg', multiple=False)
output = Output()

def on_upload(change):
    if change['name'] == 'value':
        file = change['new']
        if 'content' in file:
            img_array = np.array(Image.open(BytesIO(file['content'])))
            img_array = preprocess_image(img_array)
            img_array = np.expand_dims(img_array, axis=0)
            prediction = model.predict(img_array)
            if prediction > 0.5:
                output = 'Shoplifter'
            else:
                output = 'Not a shoplifter'
            with output:
                clear_output(wait=True)
                print(f'The person is {output}.')
        else:
            print('File upload failed. Please try again.')

uploaded_file.observe(on_upload, names='value')

HBox([uploaded_file, output])

!pip install gradio

import gradio as gr
import numpy as np
import tensorflow as tf
from tensorflow.keras import layers, models
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from keras.models import Sequential
from keras.layers import Conv2D, MaxPooling2D, Flatten, Dense
from tensorflow.keras.preprocessing import image
from tensorflow.keras.applications.vgg16 import preprocess_input, decode_predictions
from PIL import Image
from io import BytesIO

# Define the input and output types
input_type = gr.inputs.Image(type='pil', label='Upload an image')
output_type = gr.outputs.Label(num_top_classes=1, label='Prediction')

# Define the prediction function
def predict(img):
    # Preprocess the image
    img_array = image.load_img(img, target_size=(180, 180))
    img_array = image.img_to_array(img_array)
    img_array = np.expand_dims(img_array, axis=0)
    img_array = preprocess_input(img_array)

    # Make predictions
    prediction = model.predict(img_array)
    if prediction > 0.5:
        label = 'Shoplifter'
    else:
        label = 'Not a shoplifter'
    return label

# Define the Gradio interface
iface = gr.Interface(predict, input_type=input_type, output_type=output_type)

# Launch the Gradio interface
iface.launch()

import gradio as gr
from tensorflow.keras.preprocessing import image
from tensorflow.keras.applications.vgg16 import preprocess_input, decode_predictions


# Define the input and output types
input_type = gr.inputs.Image(type='pil', label='Upload an image')
output_type = gr.outputs.Label(num_top_classes=1, label='Prediction')



from flask import Flask, request, jsonify

app = Flask(__name__)

@app.route('/predict', methods=['POST'])
def predict_api():
    if request.method == 'POST':
        # Read the uploaded file
        file = request.files['file']

        # Make the prediction
        output = predict(file.filename)

        # Return the prediction as a JSON response
        return jsonify({'output': output})

    if __name__ == '__main__':
        app.run(host='0.0.0.0', port=8081, debug=True)

!python app.py

